<!-- content -->
<%# sets the id to that in the database if given a model, else makes id blank %>
<% id = defined?(fmodel_id) ? fmodel_id : "blank" %>
<div id="" class="d-inline-flex">
  <div id="myPaletteDiv-<%= id %>" style="width: 120px; height: 250px;"></div>
  <div id="graphHolder-<%= id %>" style="width:400px; height:250px; background-color: #DAE4E4;"></div>
</div>
<button id="SaveButton" onclick="save()" type="button">Save</button>
<button onclick="load()" type="button">Load</button>

<!-- dependencies -->
<script src="https://cdn.jsdelivr.net/npm/gojs/release/go.js"></script>

<!-- code -->
<script type="text/javascript">

  var diagram = new go.Diagram("graphHolder-<%= id %>");

  var $ = go.GraphObject.make;

  diagram.undoManager.isEnabled = true;

  diagram.addDiagramListener("Modified", e => {
    if (diagram.isModified) {
      document.getElementById("fmodel_graph").value = diagram.model.toJson();
      diagram.isModified = false;
    }
  });

  // helper definitions for node templates

  function nodeStyle() {
    return [
      // The Node.location comes from the "loc" property of the node data,
      // converted by the Point.parse static method.
      // If the Node.location is changed, it updates the "loc" property of the node data,
      // converting back using the Point.stringify static method.
      new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
      {
        // the Node.location is at the center of each node
        locationSpot: go.Spot.Center
      }
    ];
  }

  // Define a function for creating a "port" that is normally transparent.
  // The "name" is used as the GraphObject.portId,
  // the "align" is used to determine where to position the port relative to the body of the node,
  // the "spot" is used to control how links connect with the port and whether the port
  // stretches along the side of the node,
  // and the boolean "output" and "input" arguments control whether the user can draw links from or to the port.
  function makePort(name, align, spot, output, input) {
    var horizontal = align.equals(go.Spot.Top) || align.equals(go.Spot.Bottom);
    // the port is basically just a transparent rectangle that stretches along the side of the node,
    // and becomes colored when the mouse passes over it
    return $(go.Shape,
      {
        fill: "transparent",  // changed to a color in the mouseEnter event handler
        strokeWidth: 0,  // no stroke
        width: horizontal ? NaN : 8,  // if not stretching horizontally, just 8 wide
        height: !horizontal ? NaN : 8,  // if not stretching vertically, just 8 tall
        alignment: align,  // align the port on the main Shape
        stretch: (horizontal ? go.GraphObject.Horizontal : go.GraphObject.Vertical),
        portId: name,  // declare this object to be a "port"
        fromSpot: spot,  // declare where links may connect at this port
        fromLinkable: output,  // declare whether the user may draw links from here
        toSpot: spot,  // declare where links may connect at this port
        toLinkable: input,  // declare whether the user may draw links to here
        cursor: "pointer",  // show a different cursor to indicate potential link point
        mouseEnter: (e, port) => {  // the PORT argument will be this Shape
          if (!e.diagram.isReadOnly) port.fill = "rgba(255,0,255,0.5)";
        },
        mouseLeave: (e, port) => port.fill = "transparent"
      });
  }

  function textStyle() {
    return {
      font: "bold 11pt Lato, Helvetica, Arial, sans-serif",
      stroke: "#F8F8F8"
    }
  }

  // make nodes for pallette

  diagram.nodeTemplateMap.add("",  // the default category
    $(go.Node, "Table", nodeStyle(),
      // the main object is a Panel that surrounds a TextBlock with a rectangular Shape
      $(go.Panel, "Auto",
        $(go.Shape, "Rectangle",
          { fill: "#282c34", stroke: "#00A9C9", strokeWidth: 3.5 },
          new go.Binding("figure", "figure")),
        $(go.TextBlock, textStyle(),
          {
            margin: 8,
            maxSize: new go.Size(160, NaN),
            wrap: go.TextBlock.WrapFit,
            editable: true
          },
          new go.Binding("text").makeTwoWay())
      ),
      // four named ports, one on each side:
      makePort("T", go.Spot.Top, go.Spot.TopSide, false, true),
      makePort("L", go.Spot.Left, go.Spot.LeftSide, true, true),
      makePort("R", go.Spot.Right, go.Spot.RightSide, true, true),
      makePort("B", go.Spot.Bottom, go.Spot.BottomSide, true, false)
    ));

  // create the Palette

  var myPalette = new go.Palette("myPaletteDiv-<%= id %>",
    {
      nodeTemplateMap: diagram.nodeTemplateMap,
      model: new go.GraphLinksModel([
        { text: "Feature" }
      ])
    }
  );

  // // the Palette's node template is different from the main Diagram's
  // myPalette.nodeTemplate =
  //   $(go.Node, "Horizontal",
  //     $(go.Shape,
  //       { width: 14, height: 14, fill: "white" },
  //       new go.Binding("fill", "color")),
  //     $(go.TextBlock,
  //       new go.Binding("text", "color"))
  //   );

  // // the list of data to show in the Palette
  // myPalette.model.nodeDataArray = [
  //   { key: "C", color: "cyan" },
  //   { key: "LC", color: "lightcyan" },
  //   { key: "A", color: "aquamarine" },
  //   { key: "T", color: "turquoise" },
  //   { key: "PB", color: "powderblue" },
  //   { key: "asdf", color: "lightblue" },
  //   { key: "LSB", color: "lightskyblue" },
  //   { key: "DSB", color: "white" }
  // ];


  function save() {
    document.getElementById("fmodel_graph").value = diagram.model.toJson();
    diagram.isModified = false;
  }
  function load() {
    diagram.model = go.Model.fromJson(document.getElementById("fmodel_graph").value);
  }

</script>